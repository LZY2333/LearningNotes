# 一、原始（Primitive）类型

  **1. 六种原始值: string、number、boolean、null、undefined、symbol**

  **2. 原始类型都是值,是没有可以调用的函数的**

  > '1'.tostring()是将'1'强制转换为了'String'类型的对象

  **3. '0.1 + 0.2 !== 0.3'**

  **4. string类型的值是永远不会改变的.**

  > 原始类型'string'存在栈中,只可读,修改时重新开辟内存地址并赋值给变量

  **5. null被判定为对象,因为JS是以是否以000开头判定.**

# 二、对象(Object)类型

  **1. 除了原始类型其他的都是对象类型**

# 三、typeof 和 instanceof

  **1. typeof对于原始类型来说,除了null都可以显示正确类型**

  **2. typeof对于函数显示function,其他对象显示'object'**

  **3. instanceof通过原型链正确判断对象的类型**

  ```js
  const Person = function() {}
  const p1 = new Person()
  p1 instanceof Person // true

  var str = 'hello world'
  str instanceof String // false

  var str1 = new String('hello world')
  str1 instanceof String // true
  ```

  **4. instanceof判断原始类型会抛错**

  > 除非加上下面这种函数,下面的情况同时也证明了'instanceof'并非百分百可信
  ```js
  class PrimitiveString {
    static [Symbol.hasInstance](x) {
      return typeof x === 'string'
    }
  }
  console.log('hello world' instanceof PrimitiveString) // true
  ```

# 四、类型转换

  **1. JS类型转换只有三种情况:字符串、数字、布尔值**

  **2. 转布尔值,0、-0、NaN、''、undefined、null转为false,其他均为true**

  **3. 转字符串,number、boolean、函数、symbol直接=>字符串**

  > 对象=>'[object Object]',数组[1,2]=>'1,2',
  ```js
  var a = function(){console.log('1')}
  console.log('1' + a)// 1function(){console.log('1')} 
  console.log(typeof('1' + a))// string
  ```

  **4. 转数字**

  > 字符串 '1'=>1,'a'=>NaN
  > null 转0
  > Symbol 抛错
  > 除数组的引用类型 转NaN
  > 数组 空转0,只存在一个元素且为书数字转数字,其他转NaN

  **5. 对象转原始类型会调用内置的[[ToPrimitive]]函数**

  > 第一关,如果已经是原始类型,不用转换
  > 第二关,如果倾向于转字符串就调用toString(),如果此时发现不是字符串,就会重新先调用valueOf()再调用toString()
  > 第三关,调用valueOf()
  > 最后,上面三关都没有返回原始类型,则报错
  > 也可以重写'Symbol.toPrimitive',该方法在调用转原始类型是优先级最高

  **6. 四则运算中的转换**

  > 加法运算中
  > (1) 一方为字符串,则把另一方转为字符串
  > (2) 任意方非字符串非数字,则转换为字符串和数字
  ```js
  1 + '1' // '11'
  true + true // 2
  4 + [1,2,3] // "41,2,3"
  'a' + + 'b' // -> "aNaN" 第二个加号视为一维运算符正号,'正b'为NaN
  + '1' // 1
  ```

  > 非加法运算中,一方是数字,另一方转数字

  **7. 比较运算符中的转换**

  > (1) 如果是对象,就通过'toPrimitive'转换.
  > (2) 如果是字符串就通过unicode字符索引来比较
  ```js
  let a = {
    valueOf() {
      return 0
    },
    toString() {
      return '1'
    }
  }
  a > -1 // true a是对象,所以调用了value转换
  ```

# 五、this

  **1. 直接调用foo,不管foo在哪声明,this一定是window**

  > 相当于window.foo(),省略了window.联想到可访问到window的变量,合情合理.

  **2. 对于'obj.foo()',谁调用了函数谁就是this**

  **3. 对于new的方式来说,this绑定在c上,不会被任何方式改变**

  ```js
  function foo() {
    console.log(this.a)
  }
  var a = 1
  foo()

  const obj = {
    a: 2,
    foo: foo
  }
  obj.foo()

  const c = new foo()
  ```

  **4. 对于箭头函数,没有this,this只取决于包裹箭头函数的第一个普通函数**

  **5. 对于函数.bind,this取决于第一个参数,如果参数为空,则为window**

  **6. 对一个fn进行多次bind,fn的this永远由第一个bind决定**

  ```js
  // fn.bind().bind(a) 等于
  let fn2 = function fn1() {
    return function() {
      return fn.apply()
    }.apply(a)
  }
  fn2()
  ```

  **7. this优先级: new > bind > obj.foo() > foo**

  **8. 箭头函数的this一旦被绑定,不会被任何方式改变**


# 六、一写无关的手记

  **1. a closure gives you access to an outer function’s scope from an inner function**

  **2. TCP三次握手，前两次为了确定能连接到服务器，第三次为了告诉服务器请保持连接我要发数据了**

  **3. TCP四次挥手，1) 我请求断开连接，2) 我收到你断开连接的请求了，3) (一段时间后)我可以关闭连接了，4) 那关闭吧**